
const post = `
<h1 class="title">정처기 실기 4. 서버 프로그램 구현3</h1>
<p class="post-date">
<span class="creation-date">작성일 : 2023-07-13</span>
<span class="modification-date">수정일 : 2023-07-13</span>
</p>
<p class="top-fixed-guide">
    <span class="red font-size-s">* 최종 암기 확인/복습을 위한 요약본</span>
    <br><mark>A071 디자인 패턴</mark>
    <br><mark>D072 개발 지원 도구</mark>
    <br><mark>D073 서버 개발</mark>
    <br><mark>C074 배치 프로그램</mark>
</p>
<hr>

<article id="sub1">
    <h2 class="sub-title"><b class="red">071</b></h2>
    <ul><li><button type="button">디자인 패턴(Design Pattern)</button><ul><li><b>모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제</b></li><li><button type="button">문제 및 배경</button>, <button type="button">실제 적용된 사례</button>, <button type="button">재사용이 가능한 샘플 코드</button> 등으로 구성됨</li><li>'바퀴를 다시 발명하지 마라(Don't reinvent the wheel)'라는 말과 같이, 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적임</li><li><button type="button" class="not-hidden">GOF(Gangs of Four)</button>의 디자인 패턴은 <button type="button" class="red">생성 패턴</button>, <button type="button" class="red">구조 패턴</button>, <button type="button" class="red">행위 패턴</button>으로 구분됨</li></ul></li><li><button type="button">생성 패턴(Creational Pattern)</button><ul><li>클래스나 객체의 생성과 참조 과정을 정의하는 패턴</li><li><button type="button" class="red">추상 팩토리</button>(<button type="button">Abstract Factory</button>)<ul><li>구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관·의존하는 객체들의 그룹으로 생성하여 추상적으로 표현함</li><li>연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능함</li></ul></li><li><button type="button" class="red">빌더</button>(<button type="button">Builder</button>)<ul><li>작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성함</li><li>객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어낼 수 있음</li></ul></li><li><button type="button" class="red">팩토리 메소드</button>(<button type="button">Factory Method</button>)<ul><li>= <button type="button">가상 생성자(Virtual Constructor) 패턴</button></li><li>객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴</li><li>상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브클래스가 담당함</li></ul></li><li><button type="button" class="red">프로토타입</button>(<button type="button">Prototype</button>)<ul><li>원본 객체를 복제하는 방법으로 객체를 생성하는 패턴</li><li>일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용</li></ul></li><li><button type="button" class="red">싱글톤</button>(<button type="button">Singleton</button>)<ul><li>하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음</li><li>클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화 할 수 있음</li></ul></li></ul></li><li><button type="button">구조 패턴(Structural Pattern)</button><ul><li>구조가 복잡한 시스템을 개발하기 쉽도록 <b>클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴</b></li><li><button type="button" class="red">어댑터</button>(<button type="button">Adapter</button>)<ul><li>호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴</li><li>기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용</li></ul></li><li><button type="button" class="red">브리지</button>(<button type="button">Bridge</button>)<ul><li>구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴</li><li>기능과 구현을 두 개의 별도 클래스로 구현함</li></ul></li><li><button type="button" class="red">컴포지트</button>(<button type="button">Composite</button>)<ul><li>여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴</li><li>객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있음</li></ul></li><li><button type="button" class="red">데코레이터</button>(<button type="button">Decorator</button>)<ul><li>객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴</li><li>임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현함</li></ul></li><li><button type="button" class="red">퍼싸드</button>(<button type="button">Facade</button>)<ul><li>복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴</li><li>서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요함</li></ul></li><li><button type="button" class="red">플라이웨이트</button>(<button type="button">Flyweight</button>)<ul><li>인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한한 공유해서 사용함으로써 메모리를 절약하는 패턴</li><li>다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있음</li></ul></li><li><button type="button" class="red">프록시</button>(<button type="button">Proxy</button>)<ul><li>접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴</li><li>네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용함</li></ul></li></ul></li><li><button type="button">행위 패턴(Behavioral Pattern)</button><ul><li>클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴</li><li><button type="button" class="red">책임 연쇄</button>(<button type="button">Chain of Responsibility</button>)<ul><li>요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴</li><li>요청을 처리할 수 있는 각 객체들이 고리(Chain)로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감</li></ul></li><li><button type="button" class="red">커맨드</button>(<button type="button">Command</button>)<ul><li>요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴</li><li>요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함</li></ul></li><li><button type="button" class="red">인터프리터</button>(<button type="button">Interpreter</button>)<ul><li>언어에 문법 표현을 정의하는 패턴</li><li>SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용함</li></ul></li><li><button type="button" class="red">반복자</button>(<button type="button">Iterator</button>)<ul><li>자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴</li><li>내부 표현 방법의 노출 없이 순차적인 접근이 가능함</li></ul></li><li><button type="button" class="red">중재자</button>(<button type="button">Mediator</button>)<ul><li>수많은 객체들 간의 복잡한 사옿작용(Interface)을 캡슐화하여 객체로 정의하는 패턴</li><li>객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음</li></ul></li><li><button type="button" class="red">메멘토</button>(<button type="button">Memento</button>)<ul><li>특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴</li><li><span class="exam">ctrl + z</span>와 같은 되돌리기 기능을 개발할 때 주로 이용함</li></ul></li><li><button type="button" class="red">옵서버</button>(<button type="button">Observer</button>)<ul><li>한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴</li><li>일대다의 의존성을 정의함</li><li>주로 분산된 시스템 간에 이벤트를 생성·발행(Publish)하고 이를 수신(Subscribe)해야 할 때 이용함</li></ul></li><li><button type="button" class="red">상태</button>(<button type="button">State</button>)<ul><li>객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴</li><li>객체 생태를 캡슐화하고 이를 참조하는 방식으로 처리함</li></ul></li><li><button type="button" class="red">전략</button>(<button type="button">Strategy</button>)<ul><li>동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴</li><li>클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능함</li></ul></li><li><button type="button" class="red">템플릿 메소드</button>(<button type="button">Template Method</button>)<ul><li>상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴</li><li>유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해줌</li></ul></li><li><button type="button" class="red">방문자</button>(<button type="button">Visitor</button>)<ul><li>각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴</li><li>분리된 처리 기능은 각 클래스를 방문(Visit)하여 수행함</li></ul></li></ul></li></ul>
</article>
<hr>
<article id="sub2">
    <h2 class="sub-title">072</h2>
    <ul><li><button type="button" class="red">통합 개발 환경</button>(<button type="button">IDE; Integrated Development Enviroment</button>)<ul><li><b>개발에 필요한</b> 환경, 즉 편집기(Editor), 컴파일러(Compiler), 디버거(Deburgger) 등의 <b>다양한 툴을 하나의 인터페이스로 통합하여 제공하는 환경</b></li><li>통합 개발 환경을 제공하는 소프트웨어</li><li>코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정이 용이함</li></ul></li><li><b>통합 개발 환경 도구의 종류</b><ul><li><button type="button" class="not-hidden">이클립스(Eclipse)</button><ul><li>개발사 : Eclipse Foundation, IBM</li><li>플랫폼 : 크로스 플랫폼</li><li>운영체제 : Windows, Linux, MacOS</li><li>지원 언어 : Java, C, C++, PHP, JSP 등</li></ul></li><li><button type="button" class="not-hidden">비주얼 스튜디오(Visual Studio)</button><ul><li>개발사 : Microsoft</li><li>플랫폼 : Win32, Win64</li><li>운영체제 : Windows</li><li>지원 언어 : Basic, C, C++, C#, .NET 등</li></ul></li><li><button type="button" class="not-hidden">엑스 코드(Xcode)</button><ul><li>개발사 : Apple</li><li>플랫폼 : Mac, iPhone</li><li>운영체제 : MacOS, iOS</li><li>지원 언어 : C, C++, C#, Java, AppleScript 등</li></ul></li><li><button type="button" class="not-hidden">안드로이드 스튜디오(Android Studio)</button><ul><li>개발사 : Google</li><li>플랫폼 : Android</li><li>운영체제 : Windows, Linux, MacOS</li><li>지원 언어 : Java, C, C++</li></ul></li><li><button type="button" class="not-hidden">IDEA</button><ul><li>개발사 : JetBrains(이전 IntelliJ)</li><li>플랫폼 : 크로스 플랫폼</li><li>운영체제 : Windows, Linux, MacOS</li><li>지원 언어 : Java, JSP, XML, Go, Kotlin, PHP 등</li></ul></li></ul></li><li><button type="button" class="red">빌드 도구</button><ul><li><b>소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물</b></li><li>전처리(Preprocessing), 컴파일(Compile) 등의 작업을 수행함</li><li><b>대표적인 빌드 도구</b><ul><li><button type="button">Ant(Another Neat Tool)</button><ul><li>아파치 소프트웨어 재단에서 개발</li><li>자바 프로젝트의 공식적인 빌드 도구</li><li>정해진 규칙이나 표준이 없음</li></ul></li><li><button type="button">Maven</button><ul><li>아파치 소프트웨어 재단에서 Ant의 대안으로 개발</li><li>의존성(Dependency)을 설정하여 라이브러리를 관리함</li><li>규칙이나 표준이 존재하여 예외 사항만 기록</li></ul></li><li><button type="button">Gradle</button><ul><li>한스 도커(Hans Dockter)가 Ant와 maven을 보완하여 개발</li><li>안드로이드 스튜디오의 공식 빌드 도구</li><li>그루비(Groovy) 기반의 빌드 스크립트를 사용함</li></ul></li></ul></li></ul></li><li><button type="button" class="red">기타 협업 도구</button> = <button type="button">협업 소프트웨어</button> = <button type="button">그룹웨어(Groupoware)</button><ul><li><b>개발에 참여하는 사람들이 서로 다른 작업 환경에서 원활이 프로젝트를 수행할 수 있도록 도와주는 도구</b></li><li>일정 관리, 업무흐름 관리, 정보 공유, 커뮤니케이션 등의 업무 보조 도구가 포함됨</li></ul></li></ul>
</article>
<hr>
<article id="sub3">
    <h2 class="sub-title">073</h2>
    <ul><li><button type="button">서버 개발</button><ul><li><b>웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작하여 웹 애플리케이션 서버(WAS)에 탑재하는 것</b></li><li>사용되는 프로그래밍 언어 : Java, JavaScript, Phtyon, PHP, Ruby 등</li><li>각 프로그래밍 언어에는 해당 언어로 서버 프로그램을 개발할 수 있도록 지원하는 프레임워크가 있음</li></ul></li><li><button type="button">서버 개발 프레임워크</button><ul><li>서버 프로그램 개발 시 <b>다양한 네트워크 설정, 요청 및 응답 처리, 아키텍처 모델 구현 등을 손쉽게 처리할 수 있도록 클래스나 인터페이스를 제공하는 소프트웨어</b></li><li>대부분은 모델-뷰-컨트롤러(MVC) 패턴을 기반으로 개발됨</li><li><b>종류</b><ul><li><button type="button">Spring</button><ul><li>JAVA를 기반으로 만든 프레임워크</li><li>전자정부 표준 프레임워크의 기반 기술로 사용됨</li></ul></li><li><button type="button">Node.js</button><ul><li>JavaScript를 기반으로 만든 프레임워크</li><li>비동기 입·출력 처리와 이벤트 위주의 높은 처리 성능을 갖고 있어 실시간으로 입·출력이 빈번한 애플리케이션에 적합함</li></ul></li><li><button type="button">Django</button><ul><li>Python을 기반으로 만든 프레임워크</li><li>컴포넌트의 재사용과 플러그인화를 강조하여 신속한 개발이 가능하도록 지원함</li></ul></li><li><button type="button">Codeigniter</button><ul><li>PHP를 기반으로 만든 프레임워크</li><li>인터페이스가 간편하며 서버 자원을 적게 사용함</li></ul></li><li><button type="button">Ruby on Rails</button><ul><li>Ruby를 기반으로 만든 프레임워크</li><li>테스트를 위한 웹 서버를 지원하며 데이터베이스 작업을 단순화, 자동화시켜 개발 코드의 길이가 짧아지게 함으로써 신속한 개발이 가능함</li></ul></li></ul></li></ul></li><li><b>서버 개발 과정</b><ul><li><b>DTO/VO, SQL, DAO, Service, Controller를 각각 구현하는 과정</b></li><li>구현 순서는 개발자가 임의로 변경할 수 있음</li><li>개발하려는 서버 프로그램의 목적, 개발 언어, 규모 등의 이유로 통합하거나 세분화할 수 있음</li><li><b>구현 과정</b><ul><li><button type="button">DTO/VO 구현</button> : 데이터 교환을 위해 사용할 객체를 만드는 과정. 송·수시한 데이터의 자료형(Data Type)에 맞는 변수 및 객체를 생성함<ul><li><button type="button" class="not-hidden">DTO; Data Transfer Object</button> : 데이터의 교환을 위해 생성되는 객체</li><li><button type="button" class="not-hidden">VO; Valude Object</button> : DTO와 동일하지만 읽기만 가능한 객체, 변경이 불가능함</li></ul></li><li><button type="button">SQL 구현</button> : 데이터의 삽입, 변경, 삭제 등의 작업을 수행할 SQL 문을 생성하는 과정. SQL문은 소스 코드 내에 직접 입력, 또는 별도의 XML 파일로 관리함</li><li><button type="button">DAO 구현</button> : 데이터베이스에 접군하고, SQL을 활용하여 데이터를 실제로 조작하는 코드를 구현하는 과정<ul><li><button type="button" class="not-hidden">DAO; Data Access Object</button> : 데이터베이스에 접근하여 데이터를 조회·생성·수정·삭제 작업을 수행하는 객체를 의미함</li></ul></li><li><button type="button">Service 구현</button> : 사용자의 요청에 응답하기 위한 로직을 구현하는 과정</li><li><button type="button">Dontroller 구현</button> : 사용자의 요청에 적절한 서비스를 호출하여, 그 결과를 사용자에게 반환하는 코드를 구현하는 과정</li></ul></li></ul></li></ul>
</article>
<hr>
<article id="sub4">
    <h2 class="sub-title">074</h2>
    <ul><li><button type="button" class="red">배치 프로그램(Batch Program)</button><ul><li>사용자와의 상호 작용 없이 <b>여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램</b></li><li><b>필수 요소</b><ul><li><button type="button">대용량 데이터</button> : 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함</li><li><button type="button">자동화</button> : 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 함</li><li><button type="button">견고성</button> : 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함</li><li><button type="button">안정성/신뢰성</button> : 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함</li><li><button type="button">성능</button> : 다른 응용 프로그램의 수행을 방해하지 않아야 함. 지정된 시간 내에 처리가 완료되어야 함</li></ul></li></ul></li><li><button type="button" class="red">배치 스케줄러(Batch Scheduler)</button><ul><li><b>일괄 처리(Batch Processing) 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구</b></li><li>특정 업무(Job)를 원하는 시간에 처리할 수 있도록 지원한다는 특성 때문에 <button type="button">잡 스케줄러(Job Scheduler)</button>라고도 불림</li><li><b>종류</b><ul><li><button type="button">스프링 배치(Spring Batch)</button><ul><li>Spring Source 사와 Accenture 사가 2007년 공동 개발한 오픈 소스 프레임워크</li><li>로그 관리, 추적, 프랜잭션 관리, 작업 처리 통계, 작업 재시작 등의 다양한 기능을 제공함</li></ul></li><li><button type="button">Quartz</button><ul><li>스프링 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈소스 라이브러리</li><li>수행할 작업과 수행 시간을 관리하는 요소들을 분리하여 일괄 처리 작업에 유연성을 제공함</li></ul></li><li><button type="button">Cron</button><ul><li>리눅스의 기본 스케줄러 도구</li><li><button type="button" class="not-hidden">crontab 명령어</button>를 통해 작업을 예약할 수 있음</li><li><b>crontab 명령어 작성 방법</b><ul><li>작업 예약 형식<ul><li><code>[분0~59] [시0~23] [일1~31] [월1~12] [요일0(일)~6(토)] [명령어]</code><br><code>*</code> : 매 시기 수행 <span class="exam">ex) * * * * */root/com_1.sh : 매월 매일 매시 매분마다 com_1.sh 실행</span><br><code>*/[단위]</code> : 시기를 단위로 나눈 나머지가 0일 때마다 명령어 수행 <span class="exam">ex) 시간 자리에 */3일 경우 : 3시간마다 실행</span><br><code>[시작시기]-[종료시기]</code> : 특정 구간에만 반복하여 명령어 실행<br><code>[시기1], [시기2], [시기3]</code> : 특정 시기에 명령어 실행</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
</article>
<hr>
`;

export default post;