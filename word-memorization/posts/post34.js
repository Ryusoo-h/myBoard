
const post = `
<h1 class="title">정처기 실기 11.응용 SW 기초 기술 활용5</h1>
<p class="post-date">
    <span class="creation-date">작성일 : 2023-07-19</span>
    <span class="modification-date">수정일 : 2023-07-19</span>
</p>
<p class="top-fixed-guide">
    <span class="red font-size-s">* 최종 암기 확인/복습을 위한 요약본</span>
    <br><mark>A152 HW 관련 신기술</mark>
    <br><mark>C153 Secure OS</mark>
    <br><mark>A154 DB 관련 신기술</mark>
    <br><mark>A155 회복/병행제어</mark>
    <br><mark>B156 교착상태</mark>
</p>
<hr>
<article id="sub1">
    <h2 class="sub-title"><b class="red">152 HW 관련 신기술</b></h2>
    <ul><li><button type="button">고가용성(HA; High Availability)</button> : 긴 시간동안 안정적인 서비스 운영을 위해 장애 발생 시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 메커니즘</li><li><button type="button">3D Printing (Three Dimension Printing)</button> : 대상을 평면에 출력하는 것이 아니라 손으로 만질 수 있는 실제 물체로 만들어내는 것. 아주 얇은 두께로 한층한층 쌓아 하나의 형태를 만들어 내는 기술을 이용함</li><li><button type="button">4D Printing (Fourth Dimension Printing)</button> : 특정 시간이나 환경 조건이 갖추어지면 스스로 형태를 변화시키거나 제조되는 자가 조립(Self-Assembly) 기술이 적용된 기술을 3D Printing하는 기술</li><li><button type="button">RAID(Redundant Array of Inexpensive Dist, Redundant Array of Independent Disk)</button><ul><li>여러 개의 하드디스크로 디스크 배열을 구성하여 파일을 구성하고 있는 데이터 블록들을 서로 다른 디스크들에 분산 저장할 경우, 그 블록들을 여러 디스크에서 동시에 읽거나 쓸 수 있으므로 디스크의 속도가 매우 향상되는데, 이 기술을 RAID라고 함</li><li><b>주요 RAID 레벨</b><ul><li><b>RAID 0</b> : <button type="button" class="not-hidden">스트라이핑</button>을 적용한 방식으로, 디스크의 개수만큼 읽기/쓰기 성능이 향상됨<ul><li><button type="button" class="not-hidden">스트라이핑</button> : 여러개의 디스크에 데이터를 나누어 기록하고 사용하는 방식. 속도가 크게 개선되지만 하나의 디스크만 손상돼도 전체 파일을 사용하지 못한다는 단점이 있음</li></ul></li><li><b>RAID 1</b> : <button type="button" class="not-hidden">미러링</button>을 적용한 방식으로, 디스크 손상을 대비할 수 있지만, 데이터를 동시에 기록하므로 쓰기 성능이 저하될 수 있음<ul><li><button type="button" class="not-hidden">미러링</button> : 동일한 데이터를 저장하고 있는 디스크를 구성하는 방식</li></ul></li><li><b>RAID 5</b> : 스트라이핑을 적용한 디스크에 오류 검출을 위한 <button type="button" class="not-hidden">패리티</button>를 저장하는 방식으로, 스트라이핑으로 인한 읽기 성능은 향상되지만, 쓰기 성능은 패리티의 연산과 저장으로 인해 저하될 수 있음<ul><li><button type="button" class="not-hidden">패리티</button> : 데이터의 오류를 검출하기 위해 데이터 비트 외에 1비트의 패리티 체크 비트를 할당하는 방법</li></ul></li><li><b>RAID 6</b> : <button type="button" class="not-hidden">이중 패러티</button>를 추가하여 안정성을 높인 방식으로, 금융업과 같이 데이터 손상이 치명적인 결과를 불러일으키는 산업에서 주로 사용함</li></ul></li></ul></li><li><button type="button">4K 해상도</button> : 차세대 고화질 모니터의 해상도를 지칭하는 용어. 가로 픽셀 수가 3840이고 세로 픽셀 수가 2160인 영상의 해상도를 말하는데, 이는 Full HDTV(920*1080)의 가로·세로 2배, 총 4배에 해당하는 초고화질의 영상임</li><li><button type="button">앤 스크린(N-Screen)</button> : N개의 서로 다른 단말기에서 동일한 콘텐츠를 자유롭게 이용할 수 있는 서비스</li><li><button type="button">컴패니언 스크린(Companion Screen)</button> : TV 방송 시청 시 방송 내용을 공유하며 추가적인 기능을 수행할 수 있는 스마트폰, 태플릿PC 등을 의미함. <button type="button" class="not-hidden">앤 스크린(N Screen)</button>의 한 종류로, <button type="button">세컨드 스크린</button>이라고도 불림</li><li><button type="button">신 클라이언트 PC(Thin Client PC)</button> : 하드디스크나 주변장치 없이 기본적인 메모리만 갖추고 서버와 네트워크로 운용되는 개인용 컴퓨터. 서버 기반 컴퓨팅과 관계가 깊음</li><li><button type="button">패블릿(Phablet)</button> : 폰과 태블릿의 합성어. 태블릿 기능을 포함한 5인치 이상의 대화면 스마트폰</li><li><button type="button">C형 유에스비(Universal Serial Bus Type-C, USB Type-C, USB-C)</button> : 범용 인터페이스 규격인 USB(Universal Serial Bus)의 표준 중 하나. 기존 A형에 비하여 크기가 작고, 24핀으로 위아래의 구분이 없어 어느 방향으로든 연결이 가능함</li><li><button type="button">멤스(MEMS; Micro-Electro Mechanical Systems)</button> : 초정밀 반도체 제조 기술을 바탕으로 센서, 액추에이터(Actuator) 등 기계 구조를 다양한 기술로 미세 가공하여 전기기계적 동작을 할 수 있도록 한 초미세 장치</li><li><button type="button">트러스트존 기술(TrustZone Technology)</button> : 하나의 프로세서(Processor) 내에 일반 애플리케이션을 처리하는 <b>일반 구역(Normal World)</b>과 보안이 필요한 애플리케이션을 처리하는 <b>보안 구역(Secure World)</b>으로 분할하여 관리하는 하드웨어 기반의 보안 기술</li><li><button type="button">엠디스크(M-DISC, Millennial DISC)</button> : 한 번의 기록만으로 자료를 영구 보관할 수 있는 광 저장장치. 디스크 표면의 무기물층에 레이저를 이용해 자료를 조각해서 기록함. 시간이 지나도 변하지 않는 금속 활자처럼 빛, 열, 습기 등의 외부요인에 영향받지 않음</li><li><button type="button">멤리스터(Memristor)</button> : 메모리(Memory)와 레지스터(Resister)의 합성어로, 전류의 방향과 양 등 기존의 경험을 모두 기억하는 특별한 소자. 레지스터(Resister), 커패시터(Capacitor), 인덕터(Inductor)에 이어 네 번째 전자회로 구성 요소라 불리고 있음</li></ul>
</article>
<hr>
<article id="sub2">
    <h2 class="sub-title">153</h2>
    <ul><li><button type="button" class="red">Secure OS</button><ul><li>기존의 운영체제(OS)에 내재된 보안 취약점을 해소하기 위해 <b>보안 기능을 갖춘 커널을 이식하여 외부의 침입으로부터 시스템 자원을 보호하는 운영체제를 의미함</b></li><li><button type="button">보안 커널</button> : 보안 기능을 갖춘 커널을 의미함. TCB를 기반으로 참조 모니터의 개념을 구현하고 집행함</li><li>보호 방법을 구현하기 복잡한 것부터 차례로 분류하면 다음과 같다<ul><li><button type="button">암호적 분리(Crytographic Separation)</button> : 내부 정보를 암호화하는 방법</li><li><button type="button">논리적 분리(Logical Separation)</button> : 프로세스의 논리적 구역을 지정하여 구역을 벗어나는 행위를 제한하는 방법</li><li><button type="button">시간적 분리(Temporal Separation)</button> : 동일 시간에 하나의 프로세스만 수행되도록 하여 동시 실행으로 발생하는 보안 취약점을 제거하는 방법</li><li><button type="button">물리적 분리(Physical Separation)</button> : 사용자별로 특정 장비만 사용하도록 제한하는 방법</li></ul></li><li><b>보안 기능</b><ul><li>식별 및 인증</li><li>임의적/강제적 접근통제</li><li>객체 재사용 보호</li><li>완전한 조정</li><li>신뢰 경로</li><li>감사 및 감사기록 축소 등</li></ul></li></ul></li><li><button type="button" class="red">참조 모니터</button>(<button type="button">Reference Monitor</button>)<ul><li><b>보호 대상 객체에 대한 접근통제를 수행하는 추상머신</b>이며, 이것을 실제로 구현한 것이 <button type="button" class="not-hidden">보안 커널</button>임</li><li><button type="button" class="not-hidden">보안 커널 데이터베이스(SKDB; Security Kernel Database)</button>를 참조하여 객체에 대한 접근 허가 여부를 결정함</li><li>참조 모니터와 보안 커널의 특징<ul><li><button type="button">격리성(Isolation)</button> : 부정 조작이 불가능해야 함</li><li><button type="button">검증가능성(Verifiability)</button> : 적절히 구현되었다는 것을 확인할 수 있어야함</li><li><button type="button">완전성(Completeness)</button> : 우회가 불가능해야 함</li></ul></li></ul></li></ul>
</article>
<hr>
<article id="sub3">
    <h2 class="sub-title"><b class="red">154 DB 관련 신기술</b></h2>
    <ul><li><button type="button">빅데이터(Big Data)</button><ul><li>기존의 관리 방법이나 분석 체계로는 처리하기 어려운 막대한 양의 정형 또는 비정형 데이터 집합</li><li>빅데이터가 주목받고 있는 이유는 기업이나 정부, 포털 등이 빅데이터를 효과적으로 분석함으로써 미래를 예측해 최적의 대응 방안을 찾고, 이를 수익으로 연결하여 새로운 가치를 창출하기 때문</li></ul></li><li><button type="button">브로드 데이터(Broad Data)</button><ul><li>다양한 채널에서 소비자와 상호 작용을 통해 생성된 것으로, 기업 마케팅에 있어 효율적이고 다양한 데이터이며, 이전에 사용하지 않았거나 알지 못했던 새로운 데이터나 기존 데이터에 새로운 가치가 더해진 데이터</li></ul></li><li><button type="button">메타 데이터(Meta Data)</button><ul><li>일련의 데이터를 정의하고 설명해주는 데이터</li><li>컴퓨터에서는 데이터 사전의 내용, 스키마 등을 의미함</li><li>HTML 문서에서는 메타 태그 내의 내용이 메타 데이터임</li></ul></li><li><button type="button">디지털 아카이빙(Digital Archiving)</button><ul><li>디지털 정보 자원을 장기적으로 보존하기 위한 작업</li><li>아날로그 콘텐츠는 디지털로 변환한 후 압축해서 저장하고, 디지털 콘텐츠도 체계적으로 분류하고 메타 데이터를 만들어 DB화 하는 작업임</li></ul></li><li><button type="button" class="red">하둡(Hadoop)</button><ul><li>오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼</li><li>일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크</li><li>구글, 야후 등에 적용되고 있음</li></ul></li><li><button type="button">맵리듀스(MapReduce)</button><ul><li>대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델</li><li>흩어져 있는 데이터를 연관성 있는 데이터 분류로 묶는 <b>Map 작업</b>을 수행한 후 중복 데이터를 제거하고 원하는 데이터를 추출하는 <b>Reduce 작업</b>을 수행함</li><li>Google에 의해 고안되었으며, 대표적인 대용량 데이터 처리를 위한 병렬 처리 기법으로 많이 사용되고 있음</li></ul></li><li><button type="button" class="red">타조(Tajo)</button><ul><li>오픈 소스 기반 분산 컴퓨팅 플랫폼인 아파치 하둡(Apache Hadoop) 기반의 분산 <button type="button" class="not-hidden">데이터 웨어하우스</button> 프로젝트<ul><li><button type="button" class="not-hidden">데이터 웨어하우스</button> : 정보와 창고의 합성어. 기업의 의사결정 과정에 효과적으로 사용될 수 있도록 여러 시스템에 분산되어 있는 데이터를 주제별로 통합·축적해 놓은 데이터베이스</li></ul></li></ul></li><li><button type="button">데이터 다이어트(Data Diet)</button><ul><li>데이터를 삭제하는 것이 아니라 압축하고, 중복된 정보는 중복을 배제하고, 새로운 기준에 따라 나누어 저장하는 작업</li></ul></li><li><button type="button" class="red">데이터 마이닝(Data Mining)</button><ul><li>대량의 데이터를 분석하여 데이터에 내재된 변수 사이의 상호관계를 규명하여 일정한 패턴을 찾아내는 기법</li></ul></li><li><button type="button" class="red">OLAP(Online Analytical Processing)</button><ul><li>다차원으로 이루어진 데이터로부터 통계적인 요약 정보를 분석하여 의사결정에 활용하는 방식</li><li><b>OLAP 연산</b> : Roll-up, Drill-down, Drill-throught, Drill-across, Pivoting, Slicing, Dicing</li></ul></li></ul>
</article>
<hr>
<article id="sub4">
    <h2 class="sub-title"><b class="red">155</b></h2>
    <ul><li><button type="button">회복(Recovery)</button><ul><li>트랜잭션을 수행하는 도중 장애가 발생하여 <b>데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구하는 작업</b></li><li><b>회복 기법의 종류</b><ul><li><button type="button" class="red">연기 갱신 기법</button>(<button type="button">Deferred Update</button>)<ul><li>트랜잭션이 성공적으로 완료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 방법</li><li>트랜잭션이 수행되는 동안 갱신된 내용은 일단 Log에 보관됨</li><li>트랜잭션의 부분 완료 시점에 Log에 보관한 갱신 내용을 실제 데이터베이스에 기록함</li><li><button type="button" class="not-hidden">Redo</button> 작업만 가능함</li></ul></li><li><button type="button" class="red">즉각 갱신 기법</button>(<button type="button">Immediate Update</button>)<ul><li>트랜잭션이 데이터를 갱신하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 방법</li><li>장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들은 Log에 보관시킴</li><li><button type="button" class="not-hidden">Redo</button>와 <button type="button" class="not-hidden">Redo</button> 모두 사용 가능함</li></ul></li><li><button type="button" class="red">그림자 페이지 대체 기법</button>(<button type="button">Shadow Paging</button>)<ul><li>갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 복사본인 <button type="button" class="not-hidden">그림자 페이지</button>를 별도 보관해 놓고, 실제 페이지를 대상으로 갱신 작업을 수행하다가 장애가 발생하여 트랜잭션 작업을 <code>Rollback</code> 시킬 때는 갱신 이후의 실제 페이지 부분을 그림자 페이지로 대체하여 회복시키는 방법</li></ul></li><li><button type="button" class="red">검사점 기법</button>(<button type="button">Check Point</button>)<ul><li>트랜잭션 실행 중 특정 단계에서 재실행할 수 있도록 갱신 내용이나 시스템에 대한 상황 등에 관한 정보와 함께 <button type="button" class="not-hidden">검사점</button>을 로그에 보관해 두고, 장애 발생 시 트랜잭션 전체를 철회하지 않고 검사점부터 회복 작업을 수행하여 회복시간을 절약하도록 하는 기법</li></ul></li></ul></li></ul></li><li><button type="button" class="red">병행제어</button>(<button type="button">Concurrency Control</button>)<ul><li>다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행 수행할 때, <b>동시에 실행되는</b> 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 <b>트랜잭션 간의 상호 작용을 제어하는 것</b></li><li>병행제어 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 발생하는 <b>문제</b><ul><li><button type="button">갱신 분실(Lost Update)</button> : 두 개 이상의 트랜잭션이 같은 자료를 공유하여 갱신할 때 갱신 결과의 일부가 없어지는 현상</li><li><button type="button">비완료 의존성(Uncommited Dependency)</button> : 하나의 트랜잭션 수행이 실패한 후 회복되기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상</li><li><button type="button">모순성</button></li><li><button type="button">연쇄 복귀 등의 문제 발생(Cascading Rollback)</button> : 병행수행되던 트랜잭션들 중 어느 하나에 문제가 생겨 <code>Rollback</code>하는 경우 다른 트랜잭션도 함께 <code>Rollback</code>되는 현상</li></ul></li><li><b>병행제어 기법의 종류</b><ul><li><button type="button" class="red">로킹(Locking)</button><ul><li>트랜잭션들이 어떤 <button type="button">로킹 단위</button>를 액세스하기 전에 Lock(잠금)을 요청해서 Lock이 허랃ㄱ외어야만 그 로킹 단위를 액세스할 수 있도록 하는 기법</li><li>주요 데이터의 액세스를 상호 배타적으로 함</li><li><button type="button">로킹 단위(Locking Granularity)</button><ul><li>병행제어에서 <b>한꺼번에 로킹할 수 있는 객체의 크기</b></li><li>데이터베이스, 파일, 레코드, 필드 등이 로킹 단위가 될 수 있음</li><li>로킹 단위가 <b>크면</b> 로크 수가 작아 <b>관리</b>하기 쉽지만 <b>병행성 수준</b>이 낮아짐</li><li>로킹 단위가 <b>작으면</b> 로크 수가 많아 <b>관리</b>하기 복잡해 오버헤드가 증가하지만 <b>병행성 수준</b>이 높아짐</li></ul></li></ul></li><li><button type="button" class="red">타임 스탬프 순서(Locking)</button><ul><li>트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 <button type="button" class="not-hidden">시간표(Time Stamp)</button>를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법</li><li>직렬성 순서를 결ㅈ어하기 위해 트랜잭션 간의 처리 순서를 미리 선택하는 기법들 중에서 가장 보편적인 방법임</li></ul></li><li><button type="button" class="red">최적 병행 수행(검증 기법, 확인 기법, 낙관적 기법)</button><ul><li>병행수행하고자 하는 대부분의 트랜잭션이 <b>판독 전용(Read Only)</b> 트랜잭션일 경우, 트랜잭션 간의 충돌률이 매우 낮아서 병행제어 기법을 사용하지 않고 실행되어도 이중 많은 트랜잭션은 시스템의 상태를 일관성 있게 유지한다는 점을 이용한 기법</li></ul></li><li><button type="button" class="red">다중 버전 기법</button><ul><li>= <button type="button">다중 버전 타임 스탬프 기법</button></li><li><button type="button" class="not-hidden">타임 스탬프</button>의 개념을 이용하는 기법</li><li><button type="button" class="not-hidden">타입 스탬프 기법</button>은 트랜잭션 및 데이터들이 이용될 때의 <b>시간</b>을 시간표로 관리하지만, <button type="button" class="not-hidden"> 다중 버전 기법</button>은 갱신될 때마다의 <b>버전</b>을 부여하여 관리함<br/></li></ul></li></ul></li></ul></li></ul>
</article>
<hr>
<article id="sub5">
    <h2 class="sub-title"><b class="red">156</b></h2>
    <ul><li><button type="button" class="red">교착상태</button>(<button type="button">Dead Lock</button>)<ul><li>상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 <b>서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상</b>을 의미함</li><li><b>교착상태 발생의 필요 충분 조건</b> : 아래 4가지 조건이 모두 충족되어야 교착상태가 발생함<ul><li><button type="button" class="red">상호 배제</button>(<button type="button">Mutual Exclusion</button>) : 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함</li><li><button type="button" class="red">점유와 대기</button>(<button type="button">Hold and Wait</button>) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함</li><li><button type="button" class="red">비선점</button>(<button type="button">Non-preemption</button>) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 함</li><li><button type="button" class="red">환형 대기</button>(<button type="button">Circular Wait</button>) : 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야함</li></ul></li><li><b>해결 방법</b><ul><li><button type="button" class="red">예방 기법</button>(<button type="button">Prevention</button>)<ul><li>교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법</li><li>교착상태 발생의 네 가지 조건 중에서 어느 하나를 제거함으로써 수행됨</li><li>자원의 낭비가 가장 심한 기법</li></ul></li><li><button type="button" class="red">회피 기법</button>(<button type="button">Avoidance</button>)<ul><li>교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법</li><li>주로 <button type="button" class="not-hidden">은행원 알고리즘</button>이 사용됨</li><li><button type="button" class="not-hidden">은행원 알고리즘(Banker's Algorithm)</button> : E. J. Dijkstra가 제안한 것으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법</li></ul></li><li><button type="button" class="red">발견 기법</button>(<button type="button">Detection</button>)<ul><li>시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것</li><li>교착상태 발견 알고리즘과 자원 할당 그래프 등을 사용할 수 있음</li></ul></li><li><button type="button" class="red">회복 기법</button>(<button type="button">Recovery</button>)<ul><li>교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것</li></ul></li></ul></li></ul></li></ul>
</article>
`;

export default post;