
const post = `
<h1 class="title">정처기 실기 12.제품 소프트웨어 패키징</h1>
<p class="post-date">
    <span class="creation-date">작성일 : 2023-07-20</span>
    <span class="modification-date">수정일 : 2023-07-20</span>
</p>
<p class="top-fixed-guide">
    <span class="red font-size-s">* 최종 암기 확인/복습을 위한 요약본</span>
    <br><mark>D157 소프트웨어 패키징</mark>
    <br><mark>B158 릴리즈 노트 작성</mark>
    <br><mark>B159 디지털 저작권 관리(DRM)</mark>
    <br><mark>C160 소프트웨어 설치 매뉴얼 작성</mark>
    <br><mark>D161 소프트웨어 사용자 매뉴얼 작성</mark>
    <br><mark>A162 소프트웨어 버전 등록</mark>
    <br><mark>C163 소프트웨어 버전 관리 도구</mark>
    <br><mark>B164 빌드 자동화 도구</mark>
</p>
<hr>

<article id="sub1">
    <h2 class="sub-title">157</h2>
    <ul><li><button type="button" class="red">소프트웨어 패키징</button><ul><li><b>모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것</b></li><li>개발자가 아니라 사용자를 중심으로 진행함</li><li>소스 코드는 향후 관리를 고려하여 모듈화하여 패키징함</li></ul></li><li><b>패키징 작업 순서</b><ol><li><button type="button">기능 식별</button> : 작성된 코드의 기능을 확인함</li><li><button type="button">모듈화</button> : 확인된 기능 단위로 코드들을 분류함</li><li><button type="button">빌드 진행</button> : 모듈 단위별로 실행 파일을 만듦</li><li><button type="button">사용자 환경 분석</button> : 웹, 모바일, PC 등 소프트웨어가 사용될 환경이나 운영체제, CPU, RAM 등의 최소 운영 환경을 정의함</li><li><button type="button">패키징 및 적용 시험</button> : 빌드된 실행 파일들을 정의된 환경에 맞게 배포용 파일 형식으로 패키징함. 정의된 환경과 동일한 환경에서 패키징 결과를 테스팅한 후 소프트웨어에 대한 불편사항을 사용자 입장에서 확인함</li><li><button type="button">패키징 변경 개선</button> : 확인된 불편 사항을 반영하기 위한 패키징의 변경 및 개선을 진행함</li><li><button type="button">배포</button> : 배포 수행 시 오류가 발생하면 해당 개발자에게 전달하여 수정을 요청함<br/></li></ol></li></ul>
</article>
<hr>
<article id="sub2">
    <h2 class="sub-title"><b class="red">158</b></h2>
    <ul><li><button type="button">릴리즈 노트(Release Note)</button><ul><li><b>소프트웨어 개발 과정에서 정리된 릴리즈 정보를 고객과 공유하기 위한 문서</b></li><li>테스트 진행 결과와 소프트웨어 사양에 대한 개발팀의 정확한 준수 여부를 확인할 수 있음</li><li>소프트웨어에 포함된 전체 기능, 서비스의 내용, 개선 사항 등을 사용자와 공유할 수 있음</li><li><b>작성 항목</b><ul><li><button type="button">Header(머릿말)</button> : 릴리즈 노트 이름, 소프트웨어 이름, 릴리즈 버전, 릴리즈 날짜, 릴리즈 노트 날짜, 릴리즈 노트 버전 등</li><li><button type="button">개요</button> : 소프트웨어 및 변경사항 전체에 대한 간략한 내용</li><li><button type="button">목적</button> : 해당 릴리스 버전에서의 새로운 기능이나 수정된 기능의 목록과 릴리즈 노트의 목적에 대한 간략한 개요</li><li><button type="button">문제 요약</button> : 수정된 버그에 대한 간략한 설명 또는 릴리즈 추가 항목에 대한 요약</li><li><button type="button">재현 항목</button> : 버그 발견에 대한 과정 설명</li><li><button type="button">수정/개선 내용</button> : 버그를 수정/개선한 내용을 간단히 설명</li><li><button type="button">사용자 영향도</button> : 사용자가 다른 기능들을 사용하는데 있어 해당 릴리즈 버전에서의 기능 변화가 미칠 수 있는 영향에 대한 설명</li><li><button type="button">SW 지원 영향도</button> : 해당 릴리즈 버전에서의 기능 변화가 다른 응용 프로그램들을 지원하는 프로세스에 미칠 수 있는 영향에 대한 설명</li><li><button type="button">노트</button> : SW/HW 설치 항목, 업그레이드, 소프트웨어 문서화에 대한 참고 항목</li><li><button type="button">면책 조항</button> : 회사 및 소프트웨어와 관련하여 참조할 사항 <span class="exam">ex) 프리웨어, 불법 복제 금지 등</span></li><li><button type="button">연락처</button> : 사용자 지원 및 문의 응대를 위한 연락처 정보</li></ul></li><li><b>작성 순서</b><ol><li><button type="button">모듈 식별</button> : 모듈별 빌드 수행 후 릴리즈 노트에 작성될 내용을 확인함</li><li><button type="button">릴리즈 정보 확인</button> : 릴리즈 노트 이름, 소프트웨어 이름, 릴리즈 버전, 릴리즈 날짜, 노트 날짜, 노트 버전 등을 확인함</li><li><button type="button">릴리즈 노트 개요 작성</button> : 소프트웨어 및 변경사항 전체에 대한 간략한 내용을 작성함</li><li><button type="button">영향도 체크</button> : 버그나 이슈 관련 내용 또는 해당 릴리즈 버전에서의 기능 변화가 다른 소프트웨어나 기능을 사용하는데 미칠 수 있는 영향에 대해 기술함</li><li><button type="button">정식 릴리즈 노트 작성</button> : Header(머릿말), 개요, 영향도 체크 항목을 포함하여 정식 릴리즈 노트에 작성될 기본 사항을 작성함</li><li><button type="button">추가 개선 항목 식별</button> : 추가 버전 릴리즈 노트 작성이 필요한 경우 추가 릴리즈 노트를 작성함</li></ol></li></ul></li></ul>
</article>
<hr>
<article id="sub3">
    <h2 class="sub-title"><b class="red">159</b></h2>
    <ul><li><button type="button">저작권</button><ul><li><b>창작자가 가지는 배타적 독점적 권리로, 타인의 침해를 받지 않을 고유한 권한</b></li><li>컴퓨터 프로그램들과 같이 복제하기 쉬운 저작물에 대해 불법 복제 및 배포 등을 막기 위한 기술적인 방법을 통칭해 저작권 보호 기술이라고 함</li></ul></li><li><button type="button" class="red">디지털 저작권 권리</button>(<button type="button">DRM; Digital Right Management</button>)<ul><li><b>저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록</b> 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 <b>디지털 콘텐츠 관리 및 보호 기술</b></li><li>원본 콘텐츠가 아날로그인 경우에는 디지털로 변환한 후 <button type="button" class="not-hidden">패키저(Packager)</button>로 <button type="button" class="not-hidden">DRM 패키징</button>을 수행함</li><li>패키징을 수행하면 콘텐츠에는 <b>암호화된 저작권자의 전자서명</b>이 포함되고 저작권자가 설정한 <b>라이선스 정보</b>가 <button type="button">클리어링 하우스(Clearing House)</button>에 등록됨</li><li><b>흐름 및 구성요소</b> : <span class="exam block">예제) 책2 481페이지 참고</span><ul><li><button type="button">클리어링 하우스(Clearing House)</button> : 저작권에 대한 사용 권한, 라이선스 발급, 암호화된 키 관리, 사용량에 따른 결제 관리 등을 수행하는 곳</li><li><button type="button">콘텐츠 제공자(Contents Provider)</button> : 콘텐츠를 제공하는 저작권자</li><li><button type="button">패키저(Packager)</button> : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램</li><li><button type="button">콘텐츠 분배자(Contents Distributor)</button> : 암호화된 콘텐츠를 유통하는 곳이나 사람</li><li><button type="button">콘텐츠 소비자(Customer)</button> : 콘텐츠를 구매해서 사용하는 주체</li><li><button type="button">DRM 컨트롤러(DRM Controller)</button> : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램</li><li><button type="button">보안 컨테이너(Security Container)</button> : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치</li></ul></li><li><b>기술 요소</b><ul><li><button type="button">암호화(Encryption)</button> : 컨텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술</li><li><button type="button">키 관리(Key Management)</button> : 컨텐츠를 암호화한 키에 대한 저장 및 분배 기술</li><li><button type="button">암호화 파일 생성(Packager)</button> : 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술</li><li><button type="button">식별 기술(Identification)</button> : 콘텐츠에 대한 식별 체계 표현 기술</li><li><button type="button">저작권 표현(Right Expression)</button> : 라이선스의 내용 표현 기술</li><li><button type="button">정책 관리(Policy Management)</button> : 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술</li><li><button type="button">크랙 방지(Tamper Resistance)</button> : 크랙에 의한 콘텐츠 사용 방지 기술</li><li><button type="button">인증(Authentication)</button> : 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술</li></ul></li></ul></li></ul>
</article>
<hr>
<article id="sub4">
    <h2 class="sub-title">160</h2>
    <ul><li><button type="button">소프트웨어 설치 매뉴얼</button><ul><li>개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서</li><li>설치 매뉴얼은 사용자 기준으로 작성함</li><li>설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명함</li><li>설치 과정에서 표시될 수 있는 오류 메시지 및 예외 상황에 관한 내용을 별도로 분류하여 설명함</li><li><b>작성 순서</b><ol><li><button type="button">기능 식별</button> : 소프트웨어의 개발 목적과 주요 기능을 흐름순으로 정리하여 기록함</li><li><button type="button">UI 분류</button> : 설치 매뉴얼을 작성할 순서대로 UI를 분류한 후 기록함</li><li><button type="button">설치 파일/백업 파일 확인</button> : 폴더 위치, 설치 파일, 백업 파일 등의 개별적인 기능을 확인하여 기록함</li><li><button type="button">Uninstall 절차 확인</button> : 직접 Uninstall을 수행하면서 그 순서를 단계별로 자세히 기록함</li><li><button type="button">이상 Case 확인</button> : 설치 과정에서 발생할 수 있는 다양한 Case를 만들어 확인하고 해당 Case에 대한 대처법을 자세하게 기록함</li><li><button type="button">최종 매뉴얼 적용</button> : 설치가 완료된 화면과 메시지를 캡쳐하여 추가함. 완성된 매뉴얼을 검토하고 고객 지원에 대한 내용을 기록함</li></ol></li></ul></li></ul>
</article>
<hr>
<article id="sub5">
    <h2 class="sub-title">161</h2>
    <ul><li><button type="button">소프트웨어 사용자 매뉴얼</button><ul><li>사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 문서로 기록한 설명서와 안내서</li><li>사용자 매뉴얼은 사용자가 소프트웨어 사용에 필요한 절차, 환경 등의 제반사항이 모두 포함되도록 작성함</li><li>소프트웨어 배포 후 발생될 수 있는 오류에 대한 패치나 기능에 대한 업그레이드를 위해 매뉴얼의 버전을 관리함</li><li>개별적으로 동작이 가능한 컴포넌트 단위로 매뉴얼을 작성함</li><li>사용자 매뉴얼은 <button type="button" class="not-hidden">컴포넌트 명세서</button>와 <button type="button" class="not-hidden">컴포넌트 구현 설계서</button>를 토대로 작성함</li><li><b>작성 순서</b><ol><li><button type="button">기능 식별</button> : 소프트웨어 개발 목적과 사용자 활용 기능을 흐름 순으로 정리하여 기록함</li><li><button type="button">사용자 화면 분류</button> : 사용자 화면을 매뉴별로 분류하여 기록함</li><li><button type="button">사용자 환경 파일 확인</button> : 폴더 위치, 사용자 로그 파일, 백업 파일 등의 개별적인 기능을 확인하여 기록함</li><li><button type="button">초기화 절차 확인</button> : 프로그램을 사용하기 위한 초기화 절차를 확인하고 그 단계를 순서대로 기록함</li><li><button type="button">이상 Case 확인</button> : 소프트웨어 사용 과정에서 발생할 수 있는 다양한 이상 Case를 만들어 확인하고 해당 Case에 대한 대처법을 자세하게 기록함</li><li><button type="button">최종 매뉴얼 적용</button> : 사용과 관련된 문의 답변(FAQ)을 정리하여 기록함. 완성된 매뉴얼을 검토하고 고객 지원에 대한 내용을 기록함</li></ol></li></ul></li></ul>
</article>
<hr>
<article id="sub6">
    <h2 class="sub-title"><b class="red">162</b></h2>
    <ul><li><b>소프트웨어 패키징의 형상 관리</b><ul><li><button type="button">형상 관리(SCM; Software Configuration Management)</button><ul><li><b>개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동</b></li><li>소프트웨어 개발의 전 단계에 적용되는 활동. 유지보수 단계에서도 수행됨</li><li>소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해요인이 최소화되도록 보증하는 것을 목적으로 함</li><li>대표적 도구 : Git, SVN, CVS</li><li><b>기능</b><ul><li><button type="button">형상 식별</button> : 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업</li><li><button type="button">버전 제어</button> : 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구(Tool)를 결합시키는 작업</li><li><button type="button">형상 통제</button> : 식별된 형상 목록에 대한 변경 요구를 검토하여 현재의 기준선(Base Line)이 잘 반영될 수 있도록 조정하는 작업</li><li><button type="button">형상 감사</button> : 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업</li><li><button type="button">형상 기록</button> : 형상의 식별, 통제, 감사 작업의 결과를 기록·관리하고 보고서를 작성하는 작업</li></ul></li></ul></li></ul></li><li><b>소프트웨어 버전 등록 관련 주요 기능</b><ul><li><button type="button">저장소(Repository)</button> : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳</li><li><button type="button">가져오기(Import)</button> : 버전 관리가 되고 있지 않은 아무것도 없는 저장소(Repository)에 처음으로 파일을 복사함</li><li><button type="button">체크아웃(Check-Out)</button> : 프로그램을 수정하기 위해 저장소(Repository)에서 파일을 받아옴. 소스 파일과 함께 버전 관리를 위한 파일들도 받아옴</li><li><button type="button">체크인(Check-In)</button> : 체크아웃 한 파일의 수정을 완료한 후 저장소(Repository)의 파일을 새로운 버전으로 갱신함</li><li><button type="button">커밋(Commit)</button> : 체크인을 수행할 떄 이전에 갱신된 내용이 있는 경우에는 충돌(Conflict)을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료함</li><li><button type="button">동기화(Update)</button> : 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화함</li></ul></li><li><b>소프트웨어 버전 등록 과정</b><ul><li><button type="button">가져오기(Import)</button> : 개발자가 저장소에 신규로 파일을 추가함</li><li><button type="button">인출(Check-Out)</button> : 수정 작업을 진행할 개발자가 저장소에 추가된 파일을 자신의 작업 공간으로 인출함</li><li><button type="button">예치(Commit)</button> : 인출한 파일을 수정한 후 설명을 붙여 저장소에 예치함</li><li><button type="button">동기화(Update)</button> : <button type="button" class="not-hidden">커밋(Commit)</button> 후 새로운 개발자가 자신의 작업 공간을 <button type="button" class="not-hidden">동기화(Update)</button>함. 이때 기존 개발자가 추가했던 파일이 전달됨</li><li><button type="button">차이(Diff)</button> : 새로운 개발자가 추가된 파일의 수정 기록(Change Log)을 확인하면서 이전 개발자가 처음 추가한 파일과 이후 변경된 파일의 차이를 확인함</li></ul></li></ul>
</article>
<hr>
<article id="sub7">
    <h2 class="sub-title">163 소프트웨어 버전 관리 도구</h2>
    <ul><li><button type="button">공유 폴더 방식</button><ul><li><b>버전 관리 자료가 지역 컴퓨터의 공유 폴더에 저장되어 관리 되는 방식</b></li><li>파일을 잘못 복사하거나 다른 위치로 복사하는 것에 대비하기 위해 파일의 변경 사항을 데이터베이스에 기록하여 관리함</li><li>종류 : SCCS, RCS, PVCS, QVCS 등</li></ul></li><li><button type="button">클라이언트/서버 방식</button><ul><li><b>버전 관리 자료가 서버에 저장되어 관리 되는 방식</b></li><li>모든 버전관리는 서버에서 수행됨</li><li>서버에 문제가 생기면 서버가 복구되기 전까지 다른 개발자와 협업 및 버전 관리 작업은 중단됨</li><li>종류 : CVS, SVN(Subversion), CVSNT, Clear Case, CMVC, Perforce 등</li></ul></li><li><button type="button">분산 저장소 방식</button><ul><li><b>버전 관리 자료가 하나의 원격 저장소와 분산된 개발자 PC의 지역 저장소에 함께 저장되어 관리되는 방식</b></li><li>지역 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 지역 저장소의 자료를 이용하여 작업할 수 있음</li><li>종류 : Git, GNU arch, DCVS, Bazaar, Mercurial, TeamWare, Bitkeeper, Plastic SCM 등</li></ul></li><li><button type="button" class="red">Subversion</button>(<button type="button">서브버전, SVN</button>)<ul><li>CVS를 개선한 것으로, 아파치 소프트웨어 재단에서 2000년에 발표함</li><li><button type="button" class="not-hidden">클라이언트/서버 구조</button>로, 서버(저장소, Repository)에는 최신 버전의 파일들과 변경 사항이 관리됨</li><li>소스가 오픈되어 있어 무료로 사용할 수 있음</li><li>CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능함</li><li><b>주요 명령어</b><ul><li><button type="button" class="code">add</button> : 새로운 파일이나 디렉터리를 버전 관리 대상으로 등록함. <code>add</code>로 등록되지 않은 대상은 <code>commit</code>이 적용되지 않음</li><li><button type="button" class="code">commit</button> : 버전 관리 대상으로 등록된 클라이언트의 소스 파일을 서버의 소스 파일에 적용함</li><li><button type="button" class="code">update</button> : 서버의 최신 <code>commit</code> 이력을 클라이언트의 소스 파일에 적용함. <code>commit</code> 전에는 매번 <code>update</code>를 수행하여 클라이언트에 적용되지 않은 서버의 변동 내역을 클라이언트에 적용함</li><li><button type="button" class="code">checkout</button> : 버전 관리 정보와 소스 파일을 서버에서 클라이언트로 받아옴</li><li><button type="button" class="code">lock/unlock</button> : 서버의 소스 파일이나 디렉터리를 잠그거나 해제함</li><li><button type="button" class="code">import</button> : 아무것도 없는 서버의 저장소에 맨 처음 소스 파일을 저장하는 명령으로, 한 번 사용하면 다시 사용하지 않음</li><li><button type="button" class="code">export</button> : 버전 관리에 대한 정보를 제외한 순수한 소스 파일만을 서버에서 받아옴</li><li><button type="button" class="code">info</button> : 지정한 파일에 대한 위치나 마지막 수정 일자 등에 대한 정보를 표시함</li><li><button type="button" class="code">diff</button> : 지정된 파일이나 경로에 대해 이전 리비전과의 차이를 표시함</li><li><button type="button" class="code">merge</button> : 다른 디렉터리에서 작업된 버전 관리 내역을 기본 개발 작업과 병합함</li></ul></li></ul></li><li><button type="button" class="red">Git</button><ul><li>리누스 토발즈(luns Torvalds)가 2005년 리눅스 커널 개발에 사용할 관리 도구로 개발한 이후 주니오 하마노(Junio Hamano)에 의해 유지 보수 되고 있음</li><li><button type="button" class="not-hidden">분산 버전 관리 시스템</button>으로 2개의 저장소, 즉 <b>지역 저장소</b>와 <b>원격 저장소</b>가 존재함</li><li>버전 관리가 지역 저장소에서 진행되므로 버전 관리가 신속하게 처리되고, 원격 저장소나 네트워크에 문제가 있어도 작업이 가능함</li><li><b>주요 명령어</b><ul><li><button type="button" class="code">add</button> : 작업 내역을 지정 저장소에 저장하기 위해 <b>스테이징 영역(Staging Area)</b>에 추가함. <code>- -all</code>옵션으로 작업 디렉터리의 모든 파일을 스테이징 영역에 추가할 수 있음</li><li><button type="button" class="code">commit</button> : 작업 내역을 <b>지역 저장소</b>에 저장함</li><li><button type="button" class="code">branch</button> : 새로운 브랜치를 생성함. 최초로 commit을 하면 마스터(master) 브랜치가 생성됨. commit 할 때마다 해당 브랜치는 가장 최근의 commit한 내용을 가리키게 됨. <code>-d</code>옵션으로 브랜치를 삭제할 수 있음</li><li><button type="button" class="code">checkout</button> : 지정한 브랜치로 이동함. 현재 작업중인 브랜치는 <b>HEAD 포인터</b>가 가리키는데 <code>checkout</code> 명령을 통해 <b>HEAD 포인터</b>를 지정한 브랜치로 이동시킴</li><li><button type="button" class="code">merge</button> : 지정한 브랜치의 변경 내역을 <b>현재 HEAD 포인터</b>가 가리키는 브랜치에 반영함으로써 두 브랜치를 병합함</li><li><button type="button" class="code">init</button> : 지역 저장소를 생성함</li><li><button type="button" class="code">remote add</button> : 원격 저장소에 연결함</li><li><button type="button" class="code">push</button> : 로컬 저장소의 변경 내역을 <b>원격 저장소에 반영함</b></li><li><button type="button" class="code">fetch</button> : 원격 저장소의 변경 <b>이력만</b>을 지역 저장소로 가져와 반영함</li><li><button type="button" class="code">clone</button> : 원격 저장소의 전체 내용을 지역 저장소로 <b>복제함</b></li></ul></li></ul></li></ul>
</article>
<hr>
<article id="sub8">
    <h2 class="sub-title"><b class="red">164</b></h2>
    <ul><li><button type="button" class="red">빌드 자동화 도구</button><ul><li><b>빌드를 포함하여 테스트 및 배포를 자동화하는 도구</b></li><li>에자일(Agile)과 같은 지속적인 통합(Continuous Integration) 개발 환경에서 유용하게 활용됨</li><li>Ant, Make, Maven, Gradle, Jenkins 등이 있음</li></ul></li><li><button type="button">Jenkins</button><ul><li><b>JAVA 기반의 오픈 소스 형태로, <button type="button" class="not-hidden">서블릿 컨테이너</button>에서 실행되는 서버 기반 도구</b><ul><li><button type="button" class="not-hidden">서블릿 컨테이너</button> : 클라이언트의 요청을 처리하기 위해 서버 측에서 실행되는 작은 프로그램 서블릿을 실행하고 서블릿의 생명주기를 관리하는 역할을 함</li></ul></li><li>가장 많이 사용되는 빌드 자동화 도구</li><li>SVN, Git 등 대부분의 형상 관리 도구와 연동이 가능함</li><li>친숙한 Web GUI 제공으로 사용이 쉬움</li></ul></li><li><button type="button">Gradle</button><ul><li><b>Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구</b></li><li>안드로이드 앱 개발 환경에서 사용함</li><li>안드로이드뿐만 아니라 플러그인을 설정하면, JAVA, C/C++, Python 등의 언어도 빌드할 수 있음</li><li>Groovy를 사용해서 만든 <button type="button" class="not-hidden">DSL(Domain Specific Language)</button>을 스크립트 언어로 사용함</li></ul></li></ul>
</article>
`;

export default post;